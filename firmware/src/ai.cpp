#include <Arduino.h>

// this code was generated by the dedalus agents, pushed for testing purposes

// Global stop flag provided elsewhere (e.g., another compilation unit / task)
extern volatile bool shouldStop;

// Use the board-defined LED pin when available; fallback to GPIO2 (common on ESP-WROOM-32 dev boards).
#ifndef LED_BUILTIN
  #define LED_BUILTIN 2
#endif

int kLedPin = LED_BUILTIN;

// Blink timing ("3 times fast")
uint32_t kFastOnMs  = 100;
uint32_t kFastOffMs = 100;

// Hold timing
uint32_t kHoldMs = 5000;

// --- Helpers ---

// Delay in small slices so we can honor shouldStop during long waits.
// Returns false if stopped early.
static bool delayWithStop(uint32_t totalMs, uint32_t sliceMs = 10) {
  uint32_t start = millis();
  while ((millis() - start) < totalMs) {
    if (shouldStop) return false;
    // Use a bounded slice to avoid delaying longer than needed.
    uint32_t elapsed = millis() - start;
    uint32_t remaining = (totalMs > elapsed) ? (totalMs - elapsed) : 0;
    uint32_t d = (remaining < sliceMs) ? remaining : sliceMs;
    delay(d);
  }
  return true;
}

static void ledOff() {
  digitalWrite(kLedPin, LOW);
}

static void ledOn() {
  digitalWrite(kLedPin, HIGH);
}

// --- Arduino lifecycle ---

void ai_test_setup() {
  // Serial is optional; used here for basic diagnostics.
  Serial.begin(115200);
  delay(50);

  // Basic error handling: sanity-check LED pin.
  if (kLedPin < 0) {
    Serial.println("[ERR] Invalid LED pin.");
    // Nothing else we can do.
    while (true) { delay(1000); }
  }

  pinMode(kLedPin, OUTPUT);
  ledOff();

  if (shouldStop) {
    Serial.println("[WARN] shouldStop is true at startup; LED will remain off.");
  }
}

void ai_test_loop() {
  // If stop requested, ensure LED is off and idle while periodically checking the flag.
  while (shouldStop) {
    ledOff();
    // Periodically re-check shouldStop without busy-waiting.
    delay(50);
  }

  // Blink 3 times fast
  for (int i = 0; i < 3; ++i) {
    if (shouldStop) { ledOff(); return; }

    ledOn();
    if (!delayWithStop(kFastOnMs)) { ledOff(); return; }

    ledOff();
    if (!delayWithStop(kFastOffMs)) { ledOff(); return; }
  }

  // Hold for 5 seconds (hold ON)
  if (shouldStop) { ledOff(); return; }
  ledOn();
  if (!delayWithStop(kHoldMs)) { ledOff(); return; }

  // Turn off briefly before repeating (optional; keeps the pattern clear)
  ledOff();
  (void)delayWithStop(50);
}